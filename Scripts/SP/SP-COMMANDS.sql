-- COMMANDS
-- by Nikolay Krasilnikov
-- This file is distributed under Apache License 2.0 (01.2004).
--   http://www.apache.org/licenses/
-- create 01.09.2010 
-- update 06.09.2010 16.09.2010 29.10.2010 02.11.2010 15.11.2010 22.11.2010
--        02.02.2011 09.02.2011 01.03.2011 13.04.2011 16.05.2011 10.06.2011
--        22.10.2011 10.11.2011 24.11.2011 01.11.2011 05.12.2011 21.12.2011
--        19.01.2012 23.01.2012 30.01.2012 07.02.2012 16.03.2012 10.04.2013
--        22.05.2013 20.08.2013 22.08.2013 25.08.2013 29.08.2013 27.09.2013
--        28.11.2013 30.05.2014 15.06.2014 16.06.2014 27.06.2014 17.07.2014
--        04.11.2013 25.11.2014 31.03.2015 27.11.2016 16.02.2017 10.04.2017
--        12.09.2017 20.11.2017 01.12.2017 20.02.2018 05.06.2019 24.10.2020
--        21.01.2021
-- Перечень команд 
-------------------------------------------------------------------------------

CREATE TABLE SP.COMMANDS
(
  ID        NUMBER(3) NOT NULL,
  NAME      VARCHAR2(30) NOT NULL,
  COMMENTS  VARCHAR2(4000) NOT NULL,
  CONSTRAINT PK_COMMANDS PRIMARY KEY(ID)  
);

CREATE UNIQUE INDEX SP.COMMANDS_NAME ON SP.COMMANDS(upper(NAME));

COMMENT ON TABLE SP.COMMANDS IS 'Перечень команд выполняемых IMan (Intergraph Manager) каждая макрооперация это выполнение команды из этой таблицы. Идентификаторы команд должны совпадать, со значениями в пакете SP.G.(SP-COMMANDS.sql)';

COMMENT ON COLUMN SP.COMMANDS.ID IS 'Идентификатор команды.';
COMMENT ON COLUMN SP.COMMANDS.NAME IS 'Имя команды.';
COMMENT ON COLUMN SP.COMMANDS.COMMENTS IS 'Описание действия.';
-- В основном грант нужен чтобы строку максимальной длины определять как
-- text SP.COMMANDS.COMMENTS%type;
GRANT SELECT ON SP.COMMANDS to public;
-------------------------------------------------------------------------------
declare
procedure Add_Command(ID in NUMBER, Name in VARCHAR2,COMMENTS in VARCHAR2)
is
--text SP.COMMANDS.COMMENTS%type;
--tmpVar NUMBER;
begin
  --d(NAME||' '||length(COMMENTS),'!!');
  insert into SP.COMMANDS values(ID, Name,COMMENTS);
--  text := COMMENTS;
--  tmpVar := ID;
--  update SP.COMMANDS set COMMENTS = text where ID = tmpVar;
end; 
--
begin
--
Add_Command(
   ID=> G.Cmd_Cancel
  ,Name=> 'Cancel'
  ,COMMENTS=> 'Команда прерывает последовательность макрокоманд и указывает IMan на возникшие проблемы при выполнении макропроцедуры. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может содержать блок, выполняемый перед завершением макропроцедуры, в котором, например, можно присвоить значение переменной "EM", которое будет передано, как сообщение об ошибке. Поле "USED_OBJ" не используется. Данная команда может вызываться автоматически при обработке ошибок времени выполнения.'
);

Add_Command(
   ID=> G.Cmd_Return
  ,Name=> 'Return'
  ,COMMENTS=> 'Команда завершает текущую макропроцедуру. Если макропроцедура была инициирована клиентом IMan, то IMan получает команду окончания макропроцедуры, квитирует её, вызывая соответствующую процедуру пакета SP.IM и переходит в режим ожидания директив пользователя. Если макропроцедура была инициирована из другой макропроцедуры, то происходит возврат в вызвавшую макропроцедуру. При этом содержимое массива OPa завершившийся макропроцедуры будет переписано в массив OPa вызывающей. После этого последняя переходит к выполнению очередной макрокоманды. Исключение! Если макропроцедура была запущена в командах "FOR_PARS_IN", "FOR_SYSTEMS" или "FOR_OBJECTS", то происходит выборка очередной порции параметров и перезапуск макропроцедуры, и лишь в случае выборки всех данных, продолжится выполнение вызывающей макропроцедуры. Поле "USED_OBJ" не используются. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Если определено поле "MACRO", то блок будет выполнен перед завершением.'
);

Add_Command(
   ID=> G.Cmd_Calculate
  ,Name=> 'Calculate'
  ,COMMENTS=> 'Данная команда предназначена для проведения каких либо расчётов и  присвоения значения рабочим параметрам текущей макропроцедуры (Массивы IP, P и OPa). Ссылка на объект в этом случае не используется. Расчёт выполняется, если поле "CONDITION" нулл или результат его вычисления равен "true". После выполнения этой команды управление переходит к следующей макрокоманде, если только данная макрокоманда не принадлежит "CASE" последовательности. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Go_To
  ,Name=> 'Go_To'
  ,COMMENTS=> 'Команда нарушает последовательность макрокоманд и передаёт управление макрокоманде с псевдонимом(ALIAS), вычисляемым как результат выражения, содержащегося в поле "MACRO". Если результат вычисления нулл или определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется. Команда не может передать управление внутрь "CASE"-последовательности макрокоманд.'
);

Add_Command(
   ID=> G.Cmd_For_Pars_In
  ,Name=> 'For_Pars_In'
  ,COMMENTS=> 'Команда выполняет макропроцедуру или создаёт объект в соответствии с полем "USED_OBJ" для каждого набора параметров из массива параметров "IPs".  Перед выполнением блока "MACRO" параметры (IP) получают значения очередного набора. Поле "MACRO" может использоваться для дополнительной настройки значений набора (массива IP) перед выполнением очередной команды или для обработки возвращённого предыдущей командой массива OPa, который кроме всего прочего содержит имя и OID объекта, созданного или обновленного последней выполненной командой "CREATE_OBJECT". Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Для преждевременного выхода из цикла можно вызывать  в макроблоке процедуру EXIT_LOOP. При этом действие, предусмотренное на данном шаге команды будет выполнено. Для выхода без выполнения действия необходимо дополнительно вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Case
  ,Name=> 'Case'
  ,COMMENTS=> 'Команда переводит последующую последовательность макроопераций вплоть до команды "WHEN_OTHERS_END CASE" в режим выполнения лишь одной команды из этой последовательности. Будет выполнена первая команда у которой поле "СONDITION", будет нулл или результат вычисления этого поля равен "true". Поля "MACRO", "СONDITION"(данной команды), и "USED_OBJ" не используются.'
);

Add_Command(
   ID=> G.Cmd_When_Others_End_Case
  ,Name=> 'When_Others_End_Case'
  ,COMMENTS=> 'Команда завершает последовательность макрокоманд начатую командой  "CASE". Если поле "MACRO" не нулл и ни одна из команд данной последовательности не была выполнена, то будет выполнен этот блок. Поля "CONDITION", и "USED_OBJ" не используются.'
);

Add_Command(
   ID=> G.Cmd_Update_Notes
  ,Name=> 'Update_Notes'
  ,COMMENTS=> 'Команда изменяет примечания у объекта, заданного параметром "OID" или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя игнорируется. Команда игнорирует параметры, имеющие иной тип чем "Note". Если примечание с именем какого либо параметра отсутствует, то оно будет добавлено. Примечания объекта с именами отсутствующими в наборе имён объекта останутся неизменными, если параметр "DELETE" имеет значение "false", в противном случае они будут удалены. Если во внутренней модели Iman присутствует такой объект, то он будет изменён соответственно. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может быть использовано для определения значения параметра "NAME" и примечаний. Поле "USED_OBJ" не используется. Для отмены действия, предусмотренного данной командой, необходимо вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Create_Object
  ,Name=> 'Create_or_Update'
  ,COMMENTS=> 'Построение или перестроение объекта модели, заданного параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT).  Полное имя текущего опорного объекта можно получить при помощи функции getRootName. Поле "USED_OBJ" указывает на объект каталога (сингл или композит), который будет построен или перестроен, основываясь на параметрах, содержащихся в массиве IP.  Блок в поле "MACRO" вычисляется до момента передачи параметров и может быть использован для заполнения значений массива IP. Для нелокальных моделей, перед выполнением блока "MACRO", массив заполняется параметрами по умолчанию за исключением обязательных к изменению параметров. Если предполагается редактирование объекта нелокальной модели, то необходимо очистить массив IP перед наполнением в блоке "MACRO" После выполнения блока "MACRO" производится проверка параметров на наличие обязательных значений и на неизменность значений, предназначенных только для чтения. Проверку можно отменить, установив глобальный параметр "TEST_MACRO_PARS" в false. Многие серверы моделей видоизменяют объект, если новые параметры допускают изменение объекта, иначе объект удаляется и создаётся заново. Для объекта типа "композит" всегда происходит перестроение объекта. Если задан параметр "OID"("ID" для локальных моделей) или "OLD_NAME", то сначала производится попытка изменить,в том числе переименовать объект, а если объект не найден, то создаётся новый объект с именем "NAME". В случае, если параметр "OLD_NAME" не null, то параметры "OLD_NAME" и "NAME" должны быть простыми именами (не содержать символ "/"). В этом случае переименование объекта не есть изменение его позиции в иерархии модели. Если задан параметр "OID"("ID" для локальных моделей), то параметр "OLD_NAME" игнорируется, но текущее имя объекта будет равно "NAME". Параметр "FORCE_OID" равный true позволяет подменить "OID" для объекта.  После получения подтверждения от IMan, если глобальный параметр "CREATE_MODEL" разрешает протоколирование, то команда заносит новый объект во внутренние таблицы IMan. При этом если объект необходимо изменить, а он отсутствует, то новый объект не добавляется. Изменение существующего объекта производятся вне зависимости от значения глобального параметра "CREATE_MODEL". Параметры объекта с именами отсутствующими в наборе имён объекта останутся неизменными, если параметр "DELETE" имеет значение "false", в противном случае они будут удалены. Если в модели отсутствует родительский объект, то строятся объекты - заменители на основании параметра "PARENT" и текущего опорного объекта. Если объект является композитом, то сначала выдаётся команда IMan на построение объекта типа "системы общего назначения"("Generic System") в соответствие с параметрами из массива IP. Далее инициируется соответствующий пакет, и в его массив P заносятся все значения из массива IP. После завершения выполнения создания объекта массив OPa макропроцедуры содержит параметры объекта, созданного или обновленного командой "CREATE_OBJECT". При этом параметр "OID" содержит его уникальный идентификатор, а параметр "POID" уникальный идентификатор его родителя. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Для отмены создания объекта из макроблока необходимо в макроблоке вызвать процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Delete_Object
  ,Name=> 'Delete_Object'
  ,COMMENTS=> 'Команда удаляет объект, заданный параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то параметр "NAME" игнорируется. Если во внутренней модели Iman присутствует такой объект, то он будет удалён. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может быть использовано для определения значения параметра "NAME". Поле "USED_OBJ" не используется. Для отмены действия, предусмотренного данной командой, необходимо вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Is_Object_Exist
  ,Name=> 'Is_Object_Exist'
  ,COMMENTS=> 'Команда выполняет проверку существования объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя игнорируется. Если объект существует, то в массиве OPa параметр "EXISTS"(типа boolean) принимает значение "true". Если объект отсутствует, то в массиве OPa параметр "EXISTS"(типа boolean) принимает значение "false". Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может быть использовано для определения значения параметров. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Change_Parent
  ,Name=> 'Change_Parent'
  ,COMMENTS=> 'Команда изменяет объект родитель у объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Параметр "NEW_POID"("NEW_PID" для локальных моделей) или  "NEW_PARENT" определяет нового родителя. Если задан параметр "NEW_POID", то параметр "NEW_PARENT" игнорируется. Если определён параметр "NEW_PARENT", то новый родитель определяется с учётом значение опорного объекта. Если во внутренней модели IMan присутствует такой объект, то он будет изменён. При этом, если в модели отсутствует родительский объект, то строятся объекты - заменители на основании параметра "PARENT" и текущего опорного объекта. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может быть использовано для определения значения параметров. Поле "USED_OBJ" не используется. Для отмены действия, предусмотренного данной командой, необходимо вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Rename
  ,Name=> 'Rename_Object'
  ,COMMENTS=> 'Команда изменяет имя у объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID", то полное имя не используется. Параметр "NEW_NAME" определяет новое ПРОСТОЕ имя объекта (модификаторы недопускаются). Если во внутренней модели Iman присутствует такой объект, то он будет изменён. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может быть использовано для определения значения параметров. Поле "USED_OBJ" не используется. Для отмены действия, предусмотренного данной командой, необходимо вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Execute
  ,Name=> 'Execute'
  ,COMMENTS=> 'Если поле "USED_OBJ" указывает на объект типа "operation", то  команда будет передана клиенту для выполнения операции, определённой параметрами массива IP. Если поле "USED_OBJ" указывает на объект типа "macro", то команда инициирует пакет, на который указывает поле  "USED_OBJ", содержащий макро-последовательность. При этом в его массив P заносятся все значения из массива IP. Если поле "USED_OBJ" указывает на объект типа "single" или "composit", то инициируется  ошибка. Блок в поле "MACRO" вычисляется до момента передачи параметров и может быть использован для заполнения значений массива IP. После завершения выполнения процедуры, массив Opa будет содержать параметры, возвращаемые либо процедурой, выполненной на клиенте, либо макропроцедуры.  Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Для отмены действия, предусмотренного данной командой, необходимо вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Set_Root
  ,Name=> 'Set_Root'
  ,COMMENTS=> 'В модели IMan все объекты объединены иерархией. Корень этой иерархии есть моделируемое предприятие или его часть. В 3D модели такой корень может, к прииеру, иметь название "PlantXX". В IMan корень иерархии обозначается символом "/". А "PlantXX" будет среди свойств корневого объекта. Кроме того символ "/" также используется как разделитель имён объектов. Каждый последующий объект после разделителя справа есть потомок левого объекта в иерархии объектов модели. Один из объектов иерархии типа "Система" может быть выбран в качестве опорного объекта. Любой объект иерархии можно адресовать относительно опорного при помощи параметров "NAME", "PARENT". По умолчанию корень иерархии является опорным объектом. Для задания текущего корня иерархии необходимо задать ссылку на новый объект типа "Система". Ссылку можно задать определив параметр "OID"("ID" для локальных моделей) или указав полное имя объекта, определяемое параметрами "NAME", "PARENT" и текущим опорным объектом. Если строка, определяющая параметр "NAME" начинается с символа "/", то она полностью определяет корневой элемента, т.е. является полным именем (параметр "PARENT" и старое значение опорного объекта будут проигнорированы). Если параметр "NAME" начинается не с символа "/", то полное имя нового корневого объекта будет получено конкатенацией значения этого параметра со значением параметра "PARENT" и полным именем текущего корневого объекта. Аналогично, если параметр "PARENT" начинается не с символа "/", то текущий корневой объект игнорируется. Параметры "NAME" и "PARENT" допускают использование модификаторов: если имя объекта начинается с символов "./"(означающих текущий объект), то они будут опущены, если имя объекта начинается с символов "../"(перейти на предыдущий уровень иерархии), то последний объект в значении имени элемента будет отброшен перед конкатенацией. Если символы "../" будут повторены N раз, то и отброшено будет N объектов. Заключительный символ "/" должен присутствовать всегда в параметре "PARENT", однако в случае его отсутствия будет дописан автоматически. Получить текущее полное имя опорного объекта можно функцией getRootName, а функция getRoot возвращает коллекцию всех его свойств.  Поле "MACRO" может быть использовано для заполнения этого значения. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_Objects
  ,Name=> 'Get_Objects'
  ,COMMENTS=> 'Команда заполняет массив объектов "OBJECTS" минимальным набором параметров объектов модели, находящихся на первом уровне иерархии, относительно  объекта заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID", то полное имя не используется. Значение параметров можно определить в блоке поля "MACRO". Минимальный набор параметров можно расширить, добавив в набор входных параметров("IP") - требуемые параметры. Если объект не содержит параметра из входного набора, то выходной набор будет содержать такой параметр и его значение будет равно значению из входного набора. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_Systems
  ,Name=> 'Get_Systems'
  ,COMMENTS=> 'Команда заполняет массив объектов "SYSTEMS" минимальным набором параметров объектов модели, имеющих параметр "IS_SYSTEM" равный "true",  находящихся на первом уровне иерархии, относительно  объекта, определяемого параметром "OID"("ID" для локальных моделей) или полным именем  объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Значение параметров можно определить в блоке поля "MACRO". Минимальный набор параметров можно расширить, добавив в набор входных параметров ("IP") - требуемые параметры. Если объект не содержит параметра из входного набора, то выходной набор будет содержать такой параметр и его значение будет равно значению из входного набора. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_Selected
  ,Name=> 'Get_Selected'
  ,COMMENTS=> 'Команда прерывает выполнение макропроцедуры и ожидает пока пользователь выделит некоторые объекты модели и передаст сигнал продолжения выполнения макропроцедуры, после чего команда заполняет массив объектов "SELECTED" минимальным набором параметров выделенных объектов модели. Минимальный набор параметров можно расширить, добавив в набор входных параметров ("IP") - требуемые параметры. Если объект не содержит параметра из входного набора, то выходной набор будет содержать такой параметр и его значение будет равно значению из входного набора. Сообщение пользователю можно передать определив параметр "MESSAGE" в блоке поля "MACRO". Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Clear_Selected
  ,Name=> 'Clear_Selected'
  ,COMMENTS=> 'Команда очищает выделение в модели, но не массив объектов "SELECTED". Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Блок поля "MACRO" выполняется перед выполнением команды и может быть использован для вывода сообщения или расчета. Поле "USED_OBJ" не используются.'
);

Add_Command(
   ID=> G.Cmd_Select_Objects
  ,Name=> 'Select_Objects'
  ,COMMENTS=> 'Команда не реализована!'
);
  
Add_Command(
   ID=> G.Cmd_Play
  ,Name=> 'Play'
  ,COMMENTS=> 'Команда проигрывает мелодию заданную параметром "NAME", типа "BEEP". Предопределённое значение "BEEP" проигрывает стандартный системный звук. Параметр "REPETITION" указывает на число повторов проигрываемого звука. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поля "USED_OBJ" и "MACRO"  не используются.'
);

Add_Command(
   ID=> G.Cmd_Get_Pars
  ,Name=> 'Get_Pars'
  ,COMMENTS=> 'Команда заполняет массив OPa параметрами объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Если среди параметров присутствует параметр TINY равный true, то будет массив Opa будет содержать только параметры присутсвующие в массиве IP. Если объект не содержит параметра из входного набора, то выходной набор будет содержать такой параметр и его значение будет равно значению из входного набора. Если параметр TINY равеy false, то будут возвращены все параметры объекта. Блок поля "MACRO" выполняется перед запросом к IMan и может быть использован для формирования имени. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);
  
Add_Command(
   ID=> G.Cmd_Declare
  ,Name=> 'Declare'
  ,COMMENTS=> 'Команда позволяет создать рабочие переменные, массивы и курсоры в текущей макропроцедуре. В макропроцедуре может присутствует несколько таких команд. На этапе трансляции содержимое всех блоков "MACRO" объединяется и помещается в секцию локальных объявлений тела пакета. Поля "USED_OBJ" и "CONDITION" не используются.'
);

Add_Command(
   ID=> G.Cmd_Declare_F
  ,Name=> 'Declare_F'
  ,COMMENTS=> 'Команда предназначена для создания локальных функций и процедур в текущей макропроцедуре. В макропроцедуре может присутствует несколько таких команд. На этапе трансляции содержимое всех блоков "MACRO" объединяется и помещается в секцию локальных объявлений тела пакета после всех объявлений, сделанных в командах "Declare" текущей макропроцедуры. Поля "USED_OBJ" и "CONDITION" не используются.'
);

Add_Command(
   ID=> G.Cmd_For_Systems
  ,Name=> 'For_Systems'
  ,COMMENTS=> 'Команда выполняет макропроцедуру на которую указывает поле "USED_OBJ" для каждого объекта из массива систем "SYSTEMS". Массив может быть заполнен вручную или при помощи команды "GET_SYSTEMS". Параметры системы заполняются в массив IP перед выполнением блока "MACRO". Остальные параметры (IP), необходимые вызываемой макропроцедуре можно присвоить при выполнении блока в поле "MACRO". Если тип "USED_OBJ" - single, то процедура выполняется клиентом. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то вся команда будет проигнорирована. Для преждевременного выхода из цикла можно вызывать  в макроблоке процедуру EXIT_LOOP. При этом действие, предусмотренное на данном шаге команды будет выполнено. Для выхода без выполнения действия необходимо дополнительно вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_For_Objects
  ,Name=> 'For_Objects'
  ,COMMENTS=> 'Команда выполняет макропроцедуру на которую указывает поле "USED_OBJ" для каждого объекта из массива "OBJECTS". Массив может быть заполнен вручную или при помощи команды "GET_OBJECTS".  Параметры очередного объекта заполняются в массив IP перед выполнением блока "MACRO". Остальные параметры (IP), необходимые вызываемой макропроцедуре можно присвоить при выполнении блока в поле "MACRO". Если тип "USED_OBJ" - single, то процедура выполняется клиентом. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то вся команда будет проигнорирована. Для преждевременного выхода из цикла можно вызывать  в макроблоке процедуру EXIT_LOOP. При этом действие, предусмотренное на данном шаге команды будет выполнено. Для выхода без выполнения действия необходимо дополнительно вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_For_Selected
  ,Name=> 'For_Selected'
  ,COMMENTS=> 'Команда выполняет макропроцедуру на которую указывает поле "USED_OBJ" для каждого объекта массива "SELECTED". Массив может быть заполнен вручную или при помощи команды "GET_SELECTED". Параметры системы заполняются в массив IP перед выполнением блока "MACRO". Остальные параметры (IP), необходимые вызываемой макропроцедуре можно присвоить при выполнении блока в поле "MACRO". Если тип "USED_OBJ" - single, то процедура выполняется клиентом. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то вся команда будет проигнорирована. Для преждевременного выхода из цикла можно вызывать  в макроблоке процедуру EXIT_LOOP. При этом действие, предусмотренное на данном шаге команды будет выполнено. Для выхода без выполнения действия необходимо дополнительно вызвать в макроблоке процедуру SKIP_EXECUTION.'
);

Add_Command(
   ID=> G.Cmd_Get_All_Systems
  ,Name=> 'Get_All_Systems'
  ,COMMENTS=> 'Команда заполняет массив систем "SYSTEMS" минимальным набором параметров каждой из СИСТЕМ модели, находящимися не выше относительно  объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Минимальный набор параметров можно расширить, добавив в набор входных параметров ("IP") - требуемые параметры. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Model3D_Commit
  ,Name=> 'Model3D_Commit'
  ,COMMENTS=> 'Команда завершает транзакцию в модели. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может содержать блок, выполняемый перед завершением транзакции. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Model3D_Flush
  ,Name=> 'Model3D_Flush'
  ,COMMENTS=> 'Команда очищает временную память сервера. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может содержать блок, выполняемый перед завершением транзакции. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Model3D_Rollback
  ,Name=> 'Model3D_Rollback'
  ,COMMENTS=> 'Команда откатывает транзакцию в модели. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может содержать блок, выполняемый перед откатом транзакции. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_MODEL3D_REFRESH
  ,Name=> 'Model3D_Refresh'
  ,COMMENTS=> 'Команда обновляет данные модели. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "MACRO" может содержать блок, выполняемый перед выполнением команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_User_Input
  ,Name=> 'Get_User_Input'
  ,COMMENTS=> 'Команда прерывает выполнение макропроцедуры и ожидает пока пользователь не примет либо изменит набор параметров (IP) и передаст сигнал продолжения выполнения макропроцедуры, после чего команда заполняет массив Opa набором параметров, подготовленных пользователем. Подготовить параметры, для заполнения пользователем можно в блоке поля "MACRO". Для передачи пользователю предупреждения можно использовать процедуру WARNING(...). Для изменения модификатора доступа к параметру можно использовать методы TVALUE : .REQUIRED и .READ_ONLY. Если пользователь не изменил обязательный параметр, то он получит соответствующее предупреждение и команда будет повторена. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_Full_Objects
  ,Name=> 'Get_Full_Objects'
  ,COMMENTS=> 'Команда заполняет массив объектов "OBJECTS" ПОЛНЫМ набором параметров объектов модели, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Значение параметров можно определить в блоке поля "MACRO". Прочитать полное имя опорного объекта можно при помощи функции getRootName. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_FUNCTION
  ,Name=> 'FUNCTION'
  ,COMMENTS=> 'Команда создаёт функцию, доступную из запроса, в схеме SP_IM c  именем F_<ALIAS>. Блок "MACRO" должен содержать текст функции, начинающийся с определения её параметров. Поля "CONDITION" и "USED_OBJ" не используются. Компиляция всех функций, определённых данными командами, производится до компиляции пакета. При ошибке компиляции, дальнейшая компиляция не производится.'
);

Add_Command(
   ID=> G.Cmd_Get_All_Objects
  ,Name=> 'Get_All_Objects'
  ,COMMENTS=> 'Команда заполняет массив "OBJECTS" минимальным набором параметров для объектов, находящимися не выше относительно  объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Минимальный набор параметров можно расширить, добавив в набор входных параметров ("IP") - требуемые параметры. Если объект не содержит параметра из входного набора, то выходной набор будет содержать такой параметр и его значение будет равно значению из входного набора. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Get_All_FullObjects
  ,Name=> 'Get_All_FullObjects'
  ,COMMENTS=> 'Команда заполняет массив "OBJECTS" полным набором параметров для объектов, находящимися не выше объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Set_GPars_Vals
  ,Name=> 'Set_GPars_Vals'
  ,COMMENTS=> 'Команда устанавливает значение глобальных параметров, как на сервере модели, так и на сервере алгоритмов. Команде можно передать несколько параметров с именами глобальных параметров и их новыми значениями. Если параметр с требуемым именем отсутствует или его тип не совпадает с типом значения, то команда вернёт ошибку. На серверах моделей, как правило глобальных параметров меньше чем на сервере алгоритмов. Для установки значения глобального параметра только на сервере алгоритмов лучше использовать объект SP.TGPAR вместо этой команды. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Toggle_Server
  ,Name=> 'Toggle_Server'
  ,COMMENTS=> 'Команда переключает сервера моделей. Первичный и вторичный сервер определяются параметрами инициализации сервера модели. Команда принимает два параметра. Первый - тип сервера с именем "SERVER" и значением из набора "Server_Types", второй "MODEL"- используется только для локального сервера и задаёт имя модели. Если требуется переключиться на локальный сервер, а требуемая модель отсутствует, то возникает ошибка. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Reload_Model
  ,Name=> 'Reload_Model'
  ,COMMENTS=> 'Команда производит одностороннюю синхронизацию модели базы данных с моделью из сервера приложений. Возможна частичная загрузка любого поддерева относительно объекта, заданного параметром "OID" или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID", то полное имя не используется. Команда заполняет параметр "ID" команды ссылкой на объект модели с которого начинается загрузка. Если такой объект - корень иерархии, то параметр "ID" будет равен - "1". Если начальный объект отсутствует во внутренней модели, то команда его построит как универсальный объект-систему. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована и блок "MACRO" не будет выполнен, иначе блок в поле "MACRO" выполняется перед выполнением  команды. Поле "USED_OBJ" не используется.'
);

Add_Command(
   ID=> G.Cmd_Set_Pars
  ,Name=> 'Set_Pars'
  ,COMMENTS=> 'Команда изменяет параметры объекта, заданного параметром "OID"("ID" для локальных моделей) или полным именем объекта, определенным параметрами "NAME", "PARENT" и текущем опорным объектом(См. комментарии к команде SET_ROOT). Если задан параметр "OID"("ID" для локальных моделей), то полное имя не используется. Новые значения параметра необходимо определить в массиве IP. Недопускается изменения положения объекта в иерархии модели, а также его прообраза. Однако возможно добавление параметров, отсутствующих в прообразе объекта. Будет выдана ошибка, если объект отсутствует в модели. Если объект отсутствует в протоколе, то он не создасться и ошибка выдана не будет. Блок поля "MACRO" выполняется перед запросом к IMan и может быть использован для формирования массива параметров объекта. Если определено поле "CONDITION" и результат его вычисления "false" или нулл, то команда будет проигнорирована. Поле "USED_OBJ" не используется.'
);

end;
/ 
-------------------------------------------------------------------------------	
CREATE OR REPLACE FUNCTION SP.to_str_CMD(CMD in NUMBER)
return VARCHAR2
-- Преобразование в имя команды по её идентификатору.
-- (COMMANDS.sql)
as
begin
  if CMD is null then return null; end if;
  case Upper(CMD)
	  when null  then return null;
	  when -1  then return 'COMPOSITE_ORIGIN';
	  when  0  then return 'CANCEL';
		when  1  then return 'RETURN';
		when  2  then return 'CALCULATE';
		when  3  then return 'GO_TO';
		when  4  then return 'FOR_PARS_IN';
		when  5  then return 'CASE';
		when  6  then return 'WHEN_OTHERS_END_CASE';
		when  7  then return 'CREATE_OR_UPDATE';
		when  8  then return 'DELETE_OBJECT';
		when  9  then return 'EXECUTE';
		when 10  then return 'SET_ROOT';
		when 11  then return 'GET_OBJECTS';
		when 12  then return 'GET_SYSTEMS';
		when 13  then return 'PLAY';
		when 14  then return 'GET_PARS';
		when 15  then return 'DECLARE';
		when 16  then return 'FOR_SYSTEMS';
		when 17  then return 'FOR_OBJECTS';
		when 18  then return 'GET_ALL_SYSTEMS';
		when 19  then return 'MODEL3D_COMMIT';
		when 20  then return 'MODEL3D_ROLLBACK';
		when 21  then return 'MODEL3D_REFRESH';
		when 22  then return 'GET_SELECTED';
		when 23  then return 'GET_USER_INPUT';
		when 24  then return 'FOR_SELECTED';
		when 25  then return 'GET_FULL_OBJECTS';
		when 26  then return 'FUNCTION';
    when 27  then return 'CLEAR_SELECTED';
    when 28  then return 'CHANGE_PARENT';
		when 29  then return 'IS_OBJECT_EXIST';
		when 30  then return 'DECLARE_F';
		when 31  then return 'UPDATE_NOTES';
		when 32  then return 'RENAME_OBJECT';
		when 33  then return 'GET_ALL_OBJECTS';
		when 34  then return 'GET_ALL_FULLOBJECTS';
		when 35  then return 'MODEL3D_FLUSH';
		when 36  then return 'SET_GPARS_VALS';
		when 37  then return 'TOGGLE_SERVER';
    when 38  then return 'SELECT_OBJECTS';
    when 39  then return 'RELOAD_MODEL';
    when 40  then return 'SET_PARS';
    
  else
	  raise_application_error(-20033,
		  'SP.to_str_CMD, Неверное значение CMD_ID: '||to_Char(CMD)||'!');
	end case;
end;
/
--
GRANT EXECUTE ON SP.to_str_CMD to public;
-- end of file
