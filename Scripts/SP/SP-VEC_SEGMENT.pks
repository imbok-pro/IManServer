CREATE OR REPLACE PACKAGE SP.VEC#SEGMENT
-- VEC#SEGMENT работа с отрезками в пространстве
-- Пакет VEC#SEGMENT зависит от пакета SP.VEC
-- by PF
-- This file is distributed under Apache License 2.0 (01.2004).
--   http://www.apache.org/licenses/
-- create 2019-06-27
-- update 2019-06-27:2019-07-05

AS
--Расстояние между отрезками.
SegmentDist Number;

--отрезки пересеклись
Intersected11 Boolean;

--номер варианта (случая)
-- 1 - p=0, q=0, ближайшие точки суть B и D +
-- 2 - p=0, q=1, ближайшие точки суть B и C +
-- 3 - ??? TODO
-- 4 - p=1, q=0, ближайшие точки суть A и D  +
-- 5 - p=1, q=1, ближайшие точки суть A и C  +
-- 6 - ??? TODO
-- 7 - ??? TODO
-- 8 - ??? TODO
-- 9 - ближайшие точки суть внутренние точки отрезков
CaseNum BINARY_INTEGER;

--опритимальная точка отрезка [AB]
PT SP.VEC.AA_Vector;
--опритимальная точка отрезка [CD]
PS SP.VEC.AA_Vector;

--==============================================================================
--Задаёт значения важнейших констант, необходимых для расчёта пересечения
--Eps0$ - абсолютная погрешность измерения линейных расстояний в мм
--  она же - абс. погрешность измерения координат вектора.
--
--Векторы параллельны друг другу
--вектор нулевой длины параллелен любому вектору
--ParallelEps$ два ЕДИНИЧЕЫХ вектора считаются сонаправленными, если расстояние 
--между ними не превосходит ParallelEps$ 
Procedure SetEps(
Eps0$ In Number  --с точностью до миллиметра (в строительстве)
, ParallelEps$ In Number  --с точностью до 0.0001
);
--==============================================================================
--Задаёт концы отрезка [AB]
Procedure SetAB(AX$ In Number, AY$ In Number, AZ$ In Number
,BX$ In Number, BY$ In Number, BZ$ In Number);
--==============================================================================
--Задаёт концы отрезка [CD]
Procedure SetCD(CX$ In Number, CY$ In Number, CZ$ In Number
,DX$ In Number, DY$ In Number, DZ$ In Number);
--==============================================================================
--Задаёт концы отрезка [AB]
Procedure SetAB(A$ In SP.VEC.AA_Vector, B$ In SP.VEC.AA_Vector);

--==============================================================================
--Задаёт концы отрезка [CD]
Procedure SetCD(C$ In SP.VEC.AA_Vector, D$ In SP.VEC.AA_Vector);

--==============================================================================
--вычисление точки пересечения отрезков [AB] и [CD], если есть
Procedure CalcSegmentIntersection;
/*
Implementation Pattern

Declare
pa# SP.VEC.AA_Vector;
pb# SP.VEC.AA_Vector;
pc# SP.VEC.AA_Vector;
pd# SP.VEC.AA_Vector;
me# Varchar2(4000);
Begin
--соединение конец-конец трансверсальных отрезков
--  pa#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035,1240000);--++
--  pb#:=SP.VEC.CreateV3(52974583.6002086, 60931920.5652035, 1240000);
--  pd#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240080);
--  pc#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240001.05);--++

--соединение конец-конец параллельных отрезков (вырожденная задача)
--  pb#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240080);--++
--  pa#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240001.05);
--  pc#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652036, 1240080);--+++
--  pd#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652036, 1242080);

--перекрытие параллельных отрезков (вырожденная задача)
  --нижний отрезок
--  pb#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240480);--++
--  pa#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652035, 1240001.05);
  --верхний отрезок
--  pc#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652036, 1240080);
--  pd#:=SP.VEC.CreateV3(52974583.6002092, 60931887.3652036, 1242080);--+++

--соединение конец-середина
--case 3
--  pc#:=SP.VEC.CreateV3(52977206.1817672, 60934951.1923352, 1238413.5864999);
--  pd#:=SP.VEC.CreateV3(52967951.7392924, 60934951.3359258, 1238413.5864999);
--  pa#:=SP.VEC.CreateV3(52973386.5195989, 60934835.3514751, 1238474.866232);
--  pb#:=SP.VEC.CreateV3(52973404.6351112, 60934951.2513198, 1238413.5864996);--+++

--case 6
--  pc#:=SP.VEC.CreateV3(52977206.1817672, 60934951.1923352, 1238413.5864999);
--  pd#:=SP.VEC.CreateV3(52967951.7392924, 60934951.3359258, 1238413.5864999);
--  pb#:=SP.VEC.CreateV3(52973386.5195989, 60934835.3514751, 1238474.866232);
--  pa#:=SP.VEC.CreateV3(52973404.6351112, 60934951.2513198, 1238413.5864996);--+++

--case 7
--  pa#:=SP.VEC.CreateV3(52977206.1817672, 60934951.1923352, 1238413.5864999);
--  pb#:=SP.VEC.CreateV3(52967951.7392924, 60934951.3359258, 1238413.5864999);
--  pc#:=SP.VEC.CreateV3(52973386.5195989, 60934835.3514751, 1238474.866232);
--  pd#:=SP.VEC.CreateV3(52973404.6351112, 60934951.2513198, 1238413.5864996);--+++

--case 8
--  pa#:=SP.VEC.CreateV3(52977206.1817672, 60934951.1923352, 1238413.5864999);
--  pb#:=SP.VEC.CreateV3(52967951.7392924, 60934951.3359258, 1238413.5864999);
--  pd#:=SP.VEC.CreateV3(52973386.5195989, 60934835.3514751, 1238474.866232);
--  pc#:=SP.VEC.CreateV3(52973404.6351112, 60934951.2513198, 1238413.5864996);--+++

--НЕ ПЕРЕСЕКАЮТСЯ
--  pa#:=SP.VEC.CreateV3(52974583.6002092,	60931887.3652035,	1240000);
--  pb#:=SP.VEC.CreateV3(52974583.6002086,	60931920.5652035, 1240000);
--  pc#:=SP.VEC.CreateV3(52977206.1817672,	60934951.1923352,	1238413.5864999);
--  pd#:=SP.VEC.CreateV3(52967951.7392924,	60934951.3359258,	1238413.5864999);

  pa#:=SP.VEC.CreateV3(52974375.5670235,	60932227.3648931,	1242599.3785326);
  pb#:=SP.VEC.CreateV3(52974075.5646966,	60932227.3695479,	1242599.3785326);
  pc#:=SP.VEC.CreateV3(52977206.1817672,	60934951.1923352,	1238413.5864999);
  pd#:=SP.VEC.CreateV3(52967951.7392924,	60934951.3359258,	1238413.5864999);

  SP.VEC#SEGMENT.SetEps(Eps0$ => 3.0, ParallelEps$=> 0.00001);
  SP.VEC#SEGMENT.SetAB(pa#,pb#);
  SP.VEC#SEGMENT.SetCD(pc#,pd#);
  SP.VEC#SEGMENT.CalcSegmentIntersection;
  
  me#:='TEST: IsIntersected = '
  ||SP.TO_.STR(SP.VEC#SEGMENT.Intersected)
  ||', Case = '||to_char(SP.VEC#SEGMENT.CaseNum)||CHR(10)||'Segment Dist '
  ||to_char(SP.VEC#SEGMENT.SegmentDist)||CHR(10);
  
  If SP.VEC#SEGMENT.Is_AB_Fragmented Then
    me#:=me#||'[AB] фрагментирован, ';
  Else
    me#:=me#||'[AB] не фрагментирован, ';
  End If;

  If SP.VEC#SEGMENT.Is_CD_Fragmented Then
    me#:=me#||'[CD] фрагментирован'||CHR(10);
  Else
    me#:=me#||'[CD] не фрагментирован'||CHR(10);
  End If;
  
  DBMS_OUTPUT.put_line(me#);
End;

*/
--==============================================================================
-- Возвращает истину, если отрезки [AB] и [CD] пересекаются с абсолютной 
-- погрешностью ZeroVectorEps$$
Function Intersected Return Boolean;

--==============================================================================
--Возвращает истину, если отрезок [AB] разбит на части 
Function Is_AB_Fragmented Return Boolean;

--==============================================================================
--Возвращает истину, если отрезок [CD] разбит на части 
Function Is_CD_Fragmented Return Boolean;

--==============================================================================
--Возвращает ориентацию отрезка [AB] 
Function OrientationAB Return BINARY_INTEGER;

--==============================================================================
--Возвращает ориентацию отрезка [CD] 
Function OrientationCD Return BINARY_INTEGER;

END VEC#SEGMENT;

