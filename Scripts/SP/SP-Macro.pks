CREATE OR REPLACE PACKAGE SP.MACRO
-- Macros execution
-- by Nikolay Krasilnikov
-- This file is distributed under Apache License 2.0 (01.2004).
--   http://www.apache.org/licenses/
-- create 07.09.2010
-- update 16.12.2015 21.12.2015 23.12.2015 11.01.2016 10.02.2016 15.02.2016
--        17.02.2016 24.02.2016 14.03.2016 01.11.2017 07.11.2017

as
-- Локальный сервер алгоритмов. Данный пакет выполняет макропроцедуры,
-- оперирующие над локальными моделями.

type TMacro is record
(
-- Состояние макропроцедуры.
State VARCHAR2(128),
-- Предыдущее состояние макропроцедуры.
OldState VARCHAR2(128),
-- Полное каталожное имя макропроцедуры
Name VARCHAR2(4000),
-- Идентификатор макропроцедуры.
ID NUMBER,
-- Текущий корневой объект.
Root SP.G.TMACRO_PARS
);

type TMacros is table of TMacro index by PLS_INTEGER;

-- Количество попыток прочесть состояние потока, 
-- при ожидании реакции макропроцедуры на сигнал,или другие действия,
-- например, передачу таблицы или массива, в процессе её выполнения.
-- Данный параметр может устанавливаться глобальным параметром.
WStateLimit PLS_INTEGER := 30;

-- Константы состояния определены в пакете SP.G.
-- При запуске потока мы отправляем туда роли пользователя 
-- и запускаем актуализацию глобальных параметров.
-- При этом должна установиться текущая модель.
-- Устанавливаем корень текущей модели.
-- При взаимодействии с потоком мы перегоняем WORK_COMMON_PARS в обе стороны,
-- при передаче параметров запускаемой команды, при ожидании реакции 
-- пользователя и при выборе объектов модели. 
-- Выбранные объекты модели передаём через массив.
-- Параметры текущей команды через потоковую функцию во временную таблицу.

-- Если в текущей сессии открыт один поток, то можно не указывать его номер.
-- Все методы работают с номером потока "1" по умолчанию.

-- Если макропроседура находится в состоянии выполнения, то ей будет послан
-- сигнал приостановки. После перехода в состояние приостановки и приёма 
-- текущего протокола выполнение макропроцедуры будет продолжено.
-- Основная сессия ожидает пока данная последовательность действий будет 
-- исполнена.
-- Если за число попыток, определённое константой WStateLimit, приостановка не
-- будет выполнена, то макропроцедура перейдёт в состояние G.MS_Waiting, а в 
-- протокол будет записано предупреждение. 
procedure forceLog(ThreadID in NUMBER default 1);

-- Функция возвращает протокол выполнения макрокоманды.
-- ThreadID -  идентификатор потока, возвращенный функцией ExecMacro.
-- Установка флага forced приводит к принудительной приостановке выполнения
-- макропроцедуры для приёма текущего лога. После завершения приёма лога 
-- работа макропроцедуры продолжается.
-- Функция не меняет состояние макропроцедуры, однако если не удалость 
-- получить отклик потока в режиме "forced",
-- то будет установлено состояние "Waiting".
function getLog(ThreadID in NUMBER default 1,
                forced in boolean default false) 
return CLOB;

-- Функция возвращает ошибки или предупреждения возникшие при выполнении 
-- макропрограммы.
-- Функция возвращает содержимое таблицы SP.WORK_ERRORS_AND_WARNINGS без
-- побочных эффектов.
-- ThreadID -  идентификатор потока, возвращенный функцией ExecMacro.
-- Функция не меняет состояние макропроцедуры.
function getErrorsAndWarnings(ThreadID in NUMBER default 1) return CLOB;

-- Процедура очищает таблицу ошибок и предупреждений текущего потока.
procedure clearErrors(ThreadID in NUMBER default 1);

-- Запрос состояния выполнения. 
-- В качестве параметра необходимо передать идентификатор потока, возвращенный
-- функцией ExecMacro.
function getState(ThreadID in NUMBER default 1) return VARCHAR2;

-- Захват демона для выполнения макропроцедуры.
-- Перед запуском макропроцедуры необходимо определить опорный объект
-- и заполнить, если необходимо её параметры.
-- Запуск макропроцедуры на выполнение осуществляет процедура Continue.
-- Для определения состояния выполнения макропроцедуры необходимо периодически
-- опрашивать состояние.
-- Если глобальный параметр "DebugThread" установлен,
-- то выполнение макропроцедуры будет происходить в текущей сессии.
-- Функция возвращает идентификатор потока.
-- Если параметр (ThreadID)определён, то он и будет использован в качестве
-- идентификатора.
-- Если Идентификатор потока (ThreadID) задать равным нулл, то будет возвращён
-- идентификатор вновь созданного потока.
-- Процедура очищает протокол текущего потока.
-- Процедура возвращает управление сразу по постановке нового потока в очередь.
-- Перед выполнением дальнейших действий с потоком необходимо опрашивать его
-- состояние до тех пор пока оно не станет G.MS_Ready.
function ExecMacro(MacroName in VARCHAR2, ThreadID in NUMBER default 1)
return NUMBER;

-- Перегруженный вариант предыдущей функции. 
-- Первый аргумент - идентификатор объекта каталога, а не полное имя.
function ExecMacro(MacroID in NUMBER, ThreadID in NUMBER default 1)
return NUMBER;

-- Установка объекта, переданного в качестве параметра в качестве опорного.
-- изменение опорного объекта возможно только при остановленной макропроцедуре.
-- Это либо момент перед запускам, либо ожидание ввода пользователя.
-- Если состояние макропроцедуры не позволяет установить опорный объект, 
-- то макропроцедура перейдёт в состояние ошибки.
-- Процедура ожидает выполнение потоком операций по установке опорного объекта.
procedure setRoot(root in SP.G.TMACRO_PARS, ThreadID in NUMBER default 1); 

-- Процедура заполняет временную таблицу SP.WORK_COMMAND_PAR_S
-- в потоке выполнения макропроцедуры содержимым этой же таблицы,
-- но заполненной в текущей сессии.
-- Процедура ожидает выполнения данной операции потоком.
procedure setPars(ThreadID in NUMBER default 1);

-- Запускаем макропроцедуру на выполнение или
-- продолжаем процесс выполнения макрокоманды,
-- остановленный по требованию пользователя или в связи с ожиданием
-- реакции пользователя.
-- Если макропроцедуре для её выполнения необходимы параметры,
-- то необходимо заполнить представление SP.V_COMMAND_PARS
-- и передать эту таблицу макропроцедуре через вызов процедуры 
-- setPars данного пакета до вызова данной процедуры.
-- Если макропроцедура была завершена, то для повторноко её запуска необходимо
-- выполнить ExecMacro, проверить положение root и параметры.
-- Если параметр byStep = true, то то будет выполнена только одна очередная 
-- макрокоманда текущей макропроцедуры.   
-- Процедура возвращает управление сразу после запуска выполнения макропроцедуры.
-- Перед выполнением дальнейших действий с потоком необходимо опрашивать его
-- состояние до тех пор пока оно не позволит выполнить другие команды.
procedure ContinueMacro(byStep in BOOLEAN default false,
                        ThreadID in NUMBER default 1);

-- Послать сигнал приостановки выполнения макропроцедуры после выполнения 
-- очередной макрокоманды.
-- Процедура возвращает управление сразу после посылки сигнала приостановки 
-- макропроцедуре.
-- Перед выполнением дальнейших действий с потоком необходимо опрашивать его
-- состояние до тех пор пока оно не позволит выполнить другие команды.
procedure PauseMacro(ThreadID in NUMBER default 1);

-- Процедура передаёт макропроцедуре набор выбранных в модели объектов.
-- Процедура ожидает выполнения данной операции потоком.
procedure setSelected(SELECTED in SP.G.TOBJECTS, ThreadID in NUMBER default 1);

-- Макропроцедура заполняет временную таблицу SP.WORK_COMMAND_PAR_S
-- в текущей сессии содержимым этой же таблицы,
-- но из сессии выполнения макропроцедуры.
-- Процедура используется при выполнении команд,
-- ожидающих реакцию пользователя.
-- Процедура ожидает выполнения данной операции потоком.
procedure getPars(ThreadID in NUMBER default 1);

-- Макропроцедура заполняет временную таблицу SP.WORK_OBJECTS_PAR_S
-- в текущей сессии параметрами опорного объекта,
-- из сессии выполнения макропроцедуры.
-- Процедура ожидает выполнения данной операции потоком.
procedure getRoot(ThreadID in NUMBER default 1);

-- Прервать выполнение макрокоманды или сбросить состояние ошибки.
-- При выполнении макропроцедуры в другой сессии эта сессия будет закрыта.
-- Процедура очищает протокол текущего потока.
-- Процедура не запускает новый поток, состояние потока становится MS_Closing
procedure ResetMacro(ThreadID in NUMBER default 1);

-- Процедура закрывает сессию потока и освобождает демона, 
-- состояние потока становится MS_Closing
-- Процедура НЕ очищает протокол потока.
procedure ExitThread(ThreadID in NUMBER default 1);

END Macro;
/