CREATE or REPLACE PACKAGE Threads.Exec 
-- KARBUILDER Threads.Exec PACKAGE
-- by Nikolai Krasilnikov
-- This file is distributed under Apache License 2.0 (01.2004).
--   http://www.apache.org/licenses/
-- create 11.11.2006
-- update 12.08.2007 24.08.2007 24.12.2015 25.12.2015 31.12.2015 29.01.2016
--        03.02.2016 11.02.2016 24.02.2016 03.03.2016 10.03.2016

AS

-- ПЕРЕМЕННЫЕ

-- Если FlagDebug  установлен, то происходит эмуляция вызова в основном потоке.
-- Данный флаг влияет только на вновь запускаемые потоки,
-- запущенный поток помнит флаг отладки с которым он был запущен.
FlagDebug BOOLEAN :=false;

-- Время ожидания ответа при запуске потока в секундах.
StartTimeout PLS_INTEGER := 5;

StartTube VARCHAR2(256) := 'StartThread';

-- ТИПЫ
-- Запись о состоянии потока
TYPE TState is RECORD (
 State NUMBER,           --  0 поток свободен и готов
                         --  1 поток занят 
												 --  2 поток свободен, но таблица ещё не принята
                         --     (необходимо несколько раз опросить состояние,
												 --      уменьшить разницу PipeBUF и BufSize)
                         -- -1 поток ждет очереди на запуск
                         -- -2 поток не запущен
												 -- -3 возникла ошибка при выполнении потока
												 -- -4 завершён
 PrBar NUMBER,						 -- % выполнения			 
 Moment DATE,            -- время присвоения значения
 Mess VARCHAR2(256),    -- произвольное сообщение
 ERR VARCHAR2(3000)      -- сообщение об ошибке Оракла, возникшей в потоке
 );

-- Сообщения потока (State.Mess) могут содержать произвольную строку.
-- Однако, данные константы введены для удобства.
-- Поток ожидает поступления команд после удачного старта.
StateWaiting constant VARCHAR2(128) := 'Waiting'; 
-- Поток ожидает очереди на выполнение.
StateStarting constant VARCHAR2(128) := 'Starting';
-- Поток завершён. 
StateStopped constant VARCHAR2(128) := 'Stopped'; 
-- Потоку передана команда восстановления после ошибки.
StateRepairing constant VARCHAR2(128) := 'Repairing'; 
-- Поток восстановлен после ошибки.
StateRepaired constant VARCHAR2(128) := 'Repaired'; 
-- Поток прерван. В потоке выполнена процедура AbortThread.
StateAborted constant VARCHAR2(128) := 'Aborted'; 
-- Сессия потока пропала.
StateDisconnected constant VARCHAR2(128) := 'Disconnected'; 


 
-- Структура описания потока. 
Type TDescThread is RECORD(
-- Номер демона, в котором запущен поток.
JobID NUMBER, 
-- Идентификатор сессии, в которой запущен поток.
JobSID NUMBER,
-- Базовое имя трубы.
PipeName VARCHAR2(128), 
-- Признак выполнении функции в потоке.
isFunc BOOLEAN, 
-- Идентификатор курсора динамического SQL.
DCursor INTEGER, 
-- Описание полей возвращаемой таблицы.
DTab DBMS_SQL.DESC_TAB2, 
-- Количество полей в записи возвращаемой таблицы.
ColCount PLS_INTEGER, 
-- Текущая не принятая колонка.
CurCol PLS_INTEGER, 
-- Количество строк таблицы принимаемых за один опрос состояния.
BufSize PLS_INTEGER,  
-- Текущее состояние.
State THREADS.EXEC.Tstate, 
-- Конвейер на одно состояние для неявного потока.
OLDState THREADS.EXEC.Tstate, 
-- Признак отладки.
FlagDebug BOOLEAN, 
-- Значение сигнала, используется для передачи сигнала в режиме отладки.
DebugSignal VARCHAR2(256), 
-- Признак неявного запуска потока.
isImplicit BOOLEAN); 

Type TPars is Table of TDescThread index by PLS_INTEGER;
-- Массив Pars спрятан в пакете Exec_I. Для доступа к описанию потока 
-- нужно использовать функцию getThread.
 
-- Явный запуск потока.
-- Функция возвращает идентификатор потока или
-- -1 ,если очередь к потокам переполнена.
-- Если в параметре указан идентификатор потока, то вновь созданный поток
-- будет записан в массив потоков под индексом, указанным в параметре.
-- Если при этом поток работает, то он будет остановлен, его сессия удалена,
-- а трубы очищены. 
FUNCTION StartNewThread(ThreadID IN PLS_INTEGER default null) 
return PLS_INTEGER;

-- Передача массива во вторичный поток.
-- Передать массив можно только в поток, запущенный явно.
-- Основное назначение данного механизма - организация циклов.
-- При помощи двух различных массивов можно задать к примеру вложенный цикл.
-- Для освобождения памяти возможна передача массива нулевой длинны.
-- Функция возвращает:
--  0 если всё успешно передано,
-- -1 ,если очередь к потокам переполнена
--      и не удалось передать управляющее сообщение 
--      ( необходим повторный запуск функции,
--      через некоторый промежуток времени или печать диагностики)
--   или предыдущая операция с данным потоком не завершена,
--   (необходимо опросить состояние потока и дождаться его завершения)
--   или возникла ошибка при выполнении предыдущих операций
--    (необходимо проанализировать ошибку,
--    после чего возможен сброс ошибки через вызов THREADS.Exec.Repair(ThId))
-- -2 ,если поток не запущен или был запущен неявно.
-- Даже в случае получение 0 НЕОБХОДИМО опросить состояние потока и только
-- после опроса состояния и подтвеждения потоком принятия массива,
-- можно запускать на исполнение функции и процедуры, использующие массив.
-- Функции перегружаемые и допускают массивы чисел, дат, строк, двоичных данных
-- и ROWID.
FUNCTION SetARR(ThreadID IN PLS_INTEGER,
                  ArrName IN VARCHAR2,
                  Arr IN ThArrs.TNums)
return PLS_INTEGER;
FUNCTION SetARR(ThreadID IN PLS_INTEGER,
                ArrName IN VARCHAR2,
                Arr IN ThArrs.TDats)
return PLS_INTEGER;
FUNCTION SetARR(ThreadID IN PLS_INTEGER,
                ArrName IN VARCHAR2,
                Arr IN ThArrs.TVChars)
return PLS_INTEGER;
FUNCTION SetARR(ThreadID IN PLS_INTEGER,
                ArrName IN VARCHAR2,
                Arr IN ThArrs.TROWIDs)
return PLS_INTEGER;
FUNCTION SetARR(ThreadID IN PLS_INTEGER,
                ArrName IN VARCHAR2,
                Arr IN ThArrs.TRAWs)
return PLS_INTEGER;

-- Передача содержимого временной тавлицы из основной сессии в сессию потока.
-- Передать данные можно только в поток, запущенный явно.
-- Таблица должна сохранять данные между транзакциями (ON COMMIT PRESERVE ROWS).
-- В потоке не должно быть незавершённых транзакций при приёме таблицы,
-- иначе возможена взаимная блокировка.
-- Необходимо предоставить привилегию на чтение таблицы пользователю THREADS.
-- Для передачи данных в обратном направлении можно воспользоваться функцией 
-- "Func" настоящего пакета.
-- Функция возвращает:
--  0 если всё успешно передано,
-- -1 ,если очередь к потокам переполнена
--      и не удалось передать управляющее сообщение 
--      ( необходим повторный запуск функции,
--      через некоторый промежуток времени или печать диагностики)
--   или предыдущая операция с данным потоком не завершена,
--   (необходимо опросить состояние потока и дождаться его завершения)
--   или возникла ошибка при выполнении предыдущих операций
--    (необходимо проанализировать ошибку,
--    после чего возможен сброс ошибки через вызов THREADS.Exec.Repair(ThId))
-- -2 ,если поток не запущен или был запущен неявно.
-- Даже в случае получение 0 НЕОБХОДИМО опросить состояние потока и только
-- после опроса состояния и подтвеждения потоком принятия данных,
-- можно запускать на исполнение функции и процедуры, использующие переданные 
-- данные.
-- В качестве полей таблицы допускаются чисела, даты, строки, двоичные данные
-- и ROWID.
-- PipeBUF размер трубы в строках таблицы.
FUNCTION SetTable(ThreadID IN PLS_INTEGER,
                  TableName IN VARCHAR2,
                  PipeBUF IN PLS_INTEGER default 200)
return PLS_INTEGER;

-- Передача сигнала в сессию потока.
-- Передать сигнал можно в поток, запущенный, как явно, так и неявно.
-- Сигналом может быть любая символьная комбинация не более 256 символов.
-- Для того чтобы принять сигнал, его нужно явно опросить в коде процедуры или 
-- функции потока.
-- Сигнал передаётся по отдельной сигнальной трубе.
-- Функция возвращает:
--  0 если всё успешно передано,
-- -1 ,если произошла ошибка передачи сигнала (возможна при посылке потоку
--     нескольких сигналов, которые им не были прочитаны)
-- -2 , если поток не выполняется.
-- Даже в случае получение 0 НЕОБХОДИМО опросить состояние потока и только
-- после опроса состояния и подтвеждения потоком принятия данных,
-- можно продолжить использование потока.
FUNCTION SetSignal(ThreadID IN PLS_INTEGER, Signal IN VARCHAR2)
return PLS_INTEGER;

-- Запуск табличной функции "ExecStr" в фоновом потоке.
-- Результат заносится во временную таблицу "TableName" текущей сессии.
-- Таблица должна сохранять данные между транзакциями (ON COMMIT PRESERVE ROWS).
-- В основной сессии не должно быть незавершённых транзакций при приёме таблицы
-- (вызов функции isReady), иначе возможена взаимная блокировка.
-- Необходимо предоставить привилегию пользователю THREADS на запуск 
-- табличной функции, а также привилегию на запись в таблицу результата.
-- Поля этой таблицы могут быть только NUMBER, VARCHAR2, DATE, ROWID, ROW.
-- Результат возвращаемый функцией ДОЛЖЕНА БЫТЬ коллекция,
-- состоящая из TableName%rowtype.
-- Если поток запущен явным образом при помощи функции StartNewThread,
-- то входной параметр ThreadID должен указывать на этот поток.
-- Если ThreadID равен null, то происходит неявный запуск потока.
-- Неявно запущенный поток закрывается после окончания выполнения функции.
-- Функция возвращает идентификатор потока, если функция запущена.
-- Функция возвращает "-1" ,если очередь к потокам переполнена,
-- или предыдущая операция с данным потоком не завершена,
-- или возникла ошибка при выполнении.
-- В этом случае необходимо опрашивать состояние потока,
-- дождаясь его завершения.
-- Сброс ошибки возможен через вызов THREADS.Exec.Repair(ThId)
-- Функция возвращает "-2" ,если поток не запущен,а ThreadID не равен null.
-- Поток работает в другой сессии и не видит переменные пакетов и временные
-- таблицы текущей - они у него свои.
-- При этом можно использовать переданные заранее массивы.
-- Строка ExecStr:
-- [schema.][package.]function_name (parametrs)
--  строка с функцией не заканчивается  ";" .
-- Входные параметры передаются ЛИТЕРАЛАМИ в ExecStr.
-- Функция используемая в ExecStr должна иметь следующee определение:
-- function[schema.][package.]name (parametrs)
--  return {TABLE of TableName%rowtype} [pipelined] ;
-- Обязательно предоставить гранты на Select и Insert на таблицу TableName
-- а также грант на выполнение функции в ExecStr.
-- Получение данных из сессии выполнения потока и их добавление в таблицу
-- производится при вызове функции isReady при этом commit не выполняется.
-- В зависимости от логики приложения commit можно выдавать после
-- каждого вызова isReady или при получении состояния "завершено".
-- IniState начальное значение State.StateVal. 
-- IniMess начальное значение State.Mess.
-- Мы получим эти значения, если опросим состояние потока до первого вызова
-- функции SendState из выполняемой функции.
-- BufSize количество строк таблицы, принимаемых за один раз.
-- PipeBUF размер трубы в строках таблицы.
-- Оба параметра отвечают за соотношение общего быстродействия
-- и потребляемой памяти.
-- Если FlagDebug  установлен, то происходит эмуляция вызова в основном потоке.
FUNCTION Func (ThreadID IN PLS_INTEGER,
               ExecStr IN VARCHAR2,-- 256
							 TableName IN VARCHAR2,
							 IniPrBar IN NUMBER default 0,
							 IniMess IN VARCHAR2 default 'Starting Func',
							 PipeBUF IN PLS_INTEGER default 200,
							 BufSize IN PLS_INTEGER default 100)
return PLS_INTEGER;

-- Функция запуска ПРОЦЕДУРЫ "ExecStr" в фоновом потоке.
-- Результатом являются изменения в постоянных таблицах базы,
-- операции ввода вывода и т.д.
-- Если поток запущен явным образом при помощи функции StartNewThread,
-- то входной параметр ThreadID должен указывать на этот поток.
-- Если ThreadID равен null, то происходит неявный запуск потока.
-- Неявно запущенный поток закрывается после окончания выполнения процедуры.
-- Функция возвращает идентификатор потока, если функция запущена.
-- Функция возвращает "-1" ,если очередь к потокам переполнена 
-- или предыдущая операция с данным потоком не завершена
-- или возникла ошибка при выполнении.
-- В этом случае необходимо опрашивать состояние потока,
-- дождаясь его освобождения.
-- Сброс ошибки возможен через вызов THREADS.Exec.Repair(ThId)
-- Функция возвращает "-2", если поток не запущен, а ThreadID не равен null.
-- Поток работает в другой сессии и не видит переменные пакетов и временные
-- таблицы текущей - они у него свои.
-- При этом можно использовать переданные заранее Массивы.
-- ExecStr должна содержать блок Pls.
-- Begin и end; можно не писать.
-- Входные параметры передаются ЛИТЕРАЛАМИ в ExecStr.
-- IniState начальное значение State.StateVal. 
-- IniMess начальное значение State.Mess.
-- Мы получим эти значения, если опросим состояние потока до первого вызова
-- функции SendState из выполняемой процедуры.
-- Если FlagDebug  установлен, то происходит эмуляция вызова в основном потоке.
FUNCTION Proc (ThreadID IN PLS_INTEGER,
               ExecStr IN VARCHAR2,
							 IniPrBar IN NUMBER default 0,
							 IniMess IN VARCHAR2 default 'Starting Proc')
return PLS_INTEGER;

-- Функция аналогична предыдущей.
-- Однако, после выполнения блока "ExecStr" будет передана временная таблица
-- TableName. Таким образом содержимое временной таблицы в потоке выполнения
-- процедуры будет передано в одноимённую временную таблицу основной сессии.
-- Таблица должна сохранять данные между транзакциями (ON COMMIT PRESERVE ROWS).
-- В основной сессии не должно быть незавершённых транзакций при приёме таблицы
-- (вызов функции isReady), иначе возможена взаимная блокировка.
-- После чего содержимое временной таблицы в сессии потока будет удалено.
-- Если FlagDebug  установлен, то происходит эмуляция вызова в основном потоке и
-- передача таблицы не происходит.
-- BufSize количество строк таблицы, принимаемых за один раз.
-- PipeBUF размер трубы в строках таблицы.
FUNCTION Proc (ThreadID IN PLS_INTEGER,
               ExecStr IN VARCHAR2,
							 TableName IN VARCHAR2,
							 IniPrBar IN NUMBER default 0,
							 IniMess IN VARCHAR2 default 'Starting Proc',
							 PipeBUF IN PLS_INTEGER default 200,
							 BufSize IN PLS_INTEGER default 100)
return PLS_INTEGER;

-- Функция возвращает запись состояния потока.
-- Приём таблицы-результата от работы табличной функции происходит при
-- вызове этой функции, причем за один вызов будет принято не более
-- BufSize строк, или менее если будет превышено время ожидания очередной
-- строки WaitTime.
-- Эти параметры задаются при вызове Exec.Func.
FUNCTION isReady	(ThreadID IN PLS_INTEGER)
return TState;

-- Функция возвращает текущий список номеров потоков.
FUNCTION User_Threads 
return TNumbers;

-- При возникновении ошибки, при исполнении процедуры или функции,
-- иногда необходимо сохранить параметры потока или провести диагностику
-- данная функция сбрасывает флаг ошибки и передаёт команду потоку
-- сбросить ошибку и передать состояние.
-- При этом состояние принимает значение 1 (поток работает),
-- а значение поля собщение - "Repairing".
-- Если поток сумеет ответить, состояние станет 0, а сообщение "Repaired".
-- Функция возвращает:
--  0 если команда передана без ошибок,
-- -2 , если поток не выполняется.
FUNCTION Repair (ThreadID IN PLS_INTEGER) return PLS_INTEGER;

-- Функция закрывает поток,открытый явным образом.  
-- Функция возвращает:
--  0 если команда передана без ошибок,
-- -2 , если поток не выполняется.
FUNCTION StopThread(ThreadID IN PLS_INTEGER) return PLS_INTEGER;

-- Функция аварийно закрывает сессию потока.
-- Функция возвращает:
--  0 если команда передана без ошибок,
-- -2 , если поток не выполняется.
FUNCTION KillThread(ThreadID IN PLS_INTEGER) return PLS_INTEGER;

-- Процедура закрывает все сессии потоков, инициированные из данной сессии.
PROCEDURE KillAll;	

-- Очищает массивы завершённых потоков.
PROCEDURE FreeMem;

-- Предоставляет описание потока.
FUNCTION get_Thread(ThreadID IN PLS_INTEGER) return TDescThread;

-- Предоставляет массив потоков текущей сессии для запроса.
FUNCTION get_Threads return THREADS.TTHREADS pipelined;							

--APPLICATION_ERROR(-20044,
--		  'Time out при передаче команды !');
-- возникает при передаче команд потоку,
-- а в потоке при невозможности передать состояние.
-- Это говорит о неправильной работе приложения юзера.
-- Нельзя заваливать командами поток, не опрашивая состояния.
-- Нельзя заваливать приложение передачами состояний из потока.
-- Нельзя надолго отвлекаться в приложении, а именно использовать потоки везде,
-- если уж решился.
end Exec;
/


